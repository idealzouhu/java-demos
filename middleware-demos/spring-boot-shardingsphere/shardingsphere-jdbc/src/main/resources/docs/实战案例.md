## 环境准备

### 启动 MySQL 数据库

```bash
$ docker run -d ^
    --name mysql-sharding ^
    -e MYSQL_ROOT_PASSWORD=root ^
    -p 3306:3306 ^
    mysql:5.7.36
```



### 创建数据

```sql
-- 创建数据库
CREATE DATABASE demo_ds0;
CREATE DATABASE demo_ds1;

-- 在 demo_ds0 数据库中创建表
USE demo_ds0;
CREATE TABLE t_user_0 (
    user_id INT NOT NULL,
    username VARCHAR(255) NOT NULL,
    PRIMARY KEY (user_id)
);
CREATE TABLE t_user_1 (
    user_id INT NOT NULL,
    username VARCHAR(255) NOT NULL,
    PRIMARY KEY (user_id)
);
-- 向 t_user_0 插入数据
INSERT INTO t_user_0 (user_id, username) VALUES (1, 'User_1');
INSERT INTO t_user_0 (user_id, username) VALUES (2, 'User_2');

-- 向 t_user_1 插入数据
INSERT INTO t_user_1 (user_id, username) VALUES (3, 'User_3');
INSERT INTO t_user_1 (user_id, username) VALUES (4, 'User_4');

-- 在 demo_ds1 数据库中创建表
USE demo_ds1;
CREATE TABLE t_user_0 (
    user_id INT NOT NULL,
    username VARCHAR(255) NOT NULL,
    PRIMARY KEY (user_id)
);
CREATE TABLE t_user_1 (
    user_id INT NOT NULL,
    username VARCHAR(255) NOT NULL,
    PRIMARY KEY (user_id)
);
-- 向 t_user_0 插入数据
INSERT INTO t_user_0 (user_id, username) VALUES (5, 'User_5');
INSERT INTO t_user_0 (user_id, username) VALUES (6, 'User_6');

-- 向 t_user_1 插入数据
INSERT INTO t_user_1 (user_id, username) VALUES (7, 'User_7');
INSERT INTO t_user_1 (user_id, username) VALUES (8, 'User_8');
```







## 项目实现

### 引入依赖

根据 [ShardingSphere-JDBC 教程](https://shardingsphere.apache.org/document/current/cn/quick-start/shardingsphere-jdbc-quick-start/) ，导入依赖。

```xml
<dependency>
    <groupId>org.apache.shardingsphere</groupId>
    <artifactId>shardingsphere-jdbc</artifactId>
    <version>5.3.2</version>
</dependency>
```

5.x.x 版本后，ShardingSphere-JDBC 的配置文件配置方式有了大的变化，**从之前和 Spring 耦合变更为完全解耦**，大家需要明确。



### 创建配置文件

以 `spring boot` 为例，编辑 `application.properties`

```yaml
# 配置 DataSource Driver
spring.datasource.driver-class-name=org.apache.shardingsphere.driver.ShardingSphereDriver
# 指定 YAML 配置文件
spring.datasource.url=jdbc:shardingsphere:classpath:xxx.yaml
```





### 创建配置文件

```yaml
server:
  port: 6060

spring:
  datasource:
    # 指定 ShardingSphere 自定义驱动类
    driver-class-name: org.apache.shardingsphere.driver.ShardingSphereDriver
    # 指定 ShardingSphere 自定义配置文件路径地址
    url: jdbc:shardingsphere:classpath:shardingsphere-config.yaml
```



### 分片配置文件

根据[用户配置教程](https://shardingsphere.apache.org/document/current/cn/user-manual/shardingsphere-jdbc/yaml-config/rules/sharding/)，自定义分片配置文件 `shardingsphere-config.yaml`

```yaml
# 数据源集合
dataSources:
  # 逻辑数据源名称
  ds_0:
    # 数据源类型
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource
    # 数据库驱动
    driverClassName: com.mysql.cj.jdbc.Driver
    # 数据库连接
    jdbcUrl: jdbc:mysql://127.0.0.1:3306/user_0?useUnicode=true&characterEncoding=UTF-8&rewriteBatchedStatements=true&allowMultiQueries=true&serverTimezone=Asia/Shanghai
    # 用户名，如果本地数据库与这个不一致，需要修改
    username: root
    # 密码，如果本地数据库与这个不一致，需要修改
    password: root

# ShardingSphere 规则配置，包含：数据分片、数据加密、读写分离等
rules:
  - !SHARDING
    # 需要数据分片的表集合
    tables:
      # 逻辑表名
      t_user:
        # 真实存在数据库的物理表集合
        actualDataNodes: ds_0.t_user_${0..1}
        # 分表策略
        tableStrategy:
          # 单分片键分表
          standard:
            # 自定义分片字段
            shardingColumn: id
            # 自定义分片算法名称，对应 {rules[0].shardingAlgorithms.user_table_hash_mod}
            shardingAlgorithmName: user_table_hash_mod
    # 数据分片算法定义集合
    shardingAlgorithms:
      # 自定义分片算法名称
      user_table_hash_mod:
        # 分片方式，HASH_MODE，按照 HASH 的方式对分片键进行操作，获取真实的物理表索引
        type: HASH_MOD
        props:
          # 物理表分片数量
          sharding-count: 2
props:
  # 是否打印逻辑SQL和实SQL，开发测试环境建议开放，生产环境建议关闭
  sql-show: true
```







### 参考资料

[看完这一篇，ShardingSphere-jdbc 实战再也不怕了 - 知乎](https://zhuanlan.zhihu.com/p/610182326)